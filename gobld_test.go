package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestGeneratePackage(t *testing.T) {
	// Create a simple AST file for testing
	fset := token.NewFileSet()
	src := "package testpkg\n"
	astFile, err := parser.ParseFile(fset, "test.go", src, 0)
	if err != nil {
		t.Fatal(err)
	}

	result := GeneratePackage(astFile, "abc123")
	expected := "// Code generated by gobetter; DO NOT EDIT.\n// gobetter:signature=abc123\n\npackage testpkg\n\n"

	if result != expected {
		t.Errorf("GeneratePackage() = %q, expected %q", result, expected)
	}

	resultNoSig := GeneratePackage(astFile, "")
	expectedNoSig := "// Code generated by gobetter; DO NOT EDIT.\n\npackage testpkg\n\n"
	if resultNoSig != expectedNoSig {
		t.Errorf("GeneratePackage() without signature = %q, expected %q", resultNoSig, expectedNoSig)
	}
}

func TestStructFieldGenerateGetter(t *testing.T) {
	tests := []struct {
		name      string
		fieldName string
		fieldType string
		acronym   bool
		expected  string
	}{
		{
			name:      "regular field",
			fieldName: "firstName",
			fieldType: "string",
			acronym:   false,
			expected:  "FirstName",
		},
		{
			name:      "acronym field",
			fieldName: "dob",
			fieldType: "string",
			acronym:   true,
			expected:  "DOB",
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			sf := &StructField{
				StructName:    "Person",
				FieldName:     test.fieldName,
				FieldTypeText: test.fieldType,
				Acronym:       test.acronym,
			}

			result := sf.GenerateGetter()

			if !strings.Contains(result, test.expected+"()") {
				t.Errorf("GenerateGetter() does not contain expected method name %q", test.expected+"()")
			}
			if !strings.Contains(result, test.fieldType) {
				t.Errorf("GenerateGetter() does not contain expected return type %q", test.fieldType)
			}
			if !strings.Contains(result, "return v."+test.fieldName) {
				t.Errorf("GenerateGetter() does not contain expected return statement")
			}
		})
	}
}

func TestStructFieldBuilderFieldStructName(t *testing.T) {
	tests := []struct {
		name       string
		structName string
		fieldName  string
		acronym    bool
		expected   string
	}{
		{
			name:       "regular field",
			structName: "Person",
			fieldName:  "firstName",
			acronym:    false,
			expected:   "Person_Builder_FirstName",
		},
		{
			name:       "acronym field",
			structName: "Person",
			fieldName:  "dob",
			acronym:    true,
			expected:   "Person_Builder_DOB",
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			sf := &StructField{
				StructName: test.structName,
				FieldName:  test.fieldName,
				Acronym:    test.acronym,
			}

			result := sf.builderFieldStructName()
			if result != test.expected {
				t.Errorf("builderFieldStructName() = %q, expected %q", result, test.expected)
			}
		})
	}
}

func TestNewStructParser(t *testing.T) {
	fset := token.NewFileSet()
	content := []byte("test content")

	parser := NewStructParser(fset, content)

	if parser.fileSet != fset {
		t.Error("fileSet not set correctly")
	}
	if string(parser.fileContent) != string(content) {
		t.Error("fileContent not set correctly")
	}
}

func TestStructParserFieldMethods(t *testing.T) {
	src := `package test

type Person struct {
	firstName string //+gob:getter
	lastName  string //+gob:getter +gob:acronym
	age       int    //+gob:_
	email     string
}`

	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "test.go", src, parser.ParseComments)
	if err != nil {
		t.Fatal(err)
	}

	sp := NewStructParser(fset, []byte(src))

	// Find the struct
	var structType *ast.StructType
	ast.Inspect(astFile, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok {
			if st, ok := ts.Type.(*ast.StructType); ok {
				structType = st
				return false
			}
		}
		return true
	})

	if structType == nil {
		t.Fatal("Could not find struct in AST")
	}

	tests := []struct {
		fieldIndex int
		getter     bool
		optional   bool
		acronym    bool
	}{
		{0, true, false, false},  // firstName
		{1, true, false, true},   // lastName
		{2, false, true, false},  // age
		{3, false, false, false}, // email
	}

	for i, test := range tests {
		field := structType.Fields.List[i]

		if sp.fieldGetter(field) != test.getter {
			t.Errorf("Field %d: fieldGetter() = %v, expected %v", i, sp.fieldGetter(field), test.getter)
		}
		if sp.fieldOptional(field) != test.optional {
			t.Errorf("Field %d: fieldOptional() = %v, expected %v", i, sp.fieldOptional(field), test.optional)
		}
		if sp.fieldAcronym(field) != test.acronym {
			t.Errorf("Field %d: fieldAcronym() = %v, expected %v", i, sp.fieldAcronym(field), test.acronym)
		}
	}
}

// TestFindAllStructs tests the discovery of nested structs
func TestFindAllStructs(t *testing.T) {
	src := `
package test

type OuterStruct struct {
	name string

	Config struct { //+gob:Constructor
		host string //+gob:getter
		port int

		Database struct { //+gob:Constructor
			driver string //+gob:getter
			host   string
		}
	}

	Settings *struct { //+gob:Constructor
		theme string //+gob:getter
	}
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", src, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse source: %v", err)
	}

	structs := findAllStructs(file, "")

	// Should find: OuterStruct, OuterStructConfig, OuterStructConfigDatabase, OuterStructSettings
	expectedStructs := []string{
		"OuterStruct",
		"OuterStructConfig",
		"OuterStructConfigDatabase",
		"OuterStructSettings",
	}

	if len(structs) != len(expectedStructs) {
		t.Errorf("Expected %d structs, got %d", len(expectedStructs), len(structs))
	}

	structNames := make(map[string]bool)
	for _, s := range structs {
		structNames[s.Name] = true
	}

	for _, expected := range expectedStructs {
		if !structNames[expected] {
			t.Errorf("Expected to find struct '%s', but it was not found", expected)
		}
	}

	// Test that top-level struct has TypeSpec
	for _, s := range structs {
		if s.Name == "OuterStruct" {
			if s.TypeSpec == nil {
				t.Errorf("Expected OuterStruct to have TypeSpec (top-level struct)")
			}
		} else {
			if s.TypeSpec != nil {
				t.Errorf("Expected %s to not have TypeSpec (inner struct)", s.Name)
			}
		}
	}
}

func TestStructParserConstructorFlags(t *testing.T) {
	tests := []struct {
		name       string
		src        string
		visibility Visibility
		process    bool
	}{
		{
			name:       "exported constructor",
			src:        "type Person struct { //+gob:Constructor\n}",
			visibility: ExportedVisibility,
			process:    true,
		},
		{
			name:       "package constructor",
			src:        "type Person struct { //+gob:constructor\n}",
			visibility: PackageLevelVisibility,
			process:    true,
		},
		{
			name:       "no constructor",
			src:        "type Person struct { //+gob:_\n}",
			visibility: NoVisibility,
			process:    true,
		},
		{
			name:       "no annotation",
			src:        "type Person struct {\n}",
			visibility: ExportedVisibility,
			process:    false,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			fullSrc := "package test\n" + test.src
			fset := token.NewFileSet()
			astFile, err := parser.ParseFile(fset, "test.go", fullSrc, parser.ParseComments)
			if err != nil {
				t.Fatal(err)
			}

			sp := NewStructParser(fset, []byte(fullSrc))

			var structType *ast.StructType
			ast.Inspect(astFile, func(n ast.Node) bool {
				if ts, ok := n.(*ast.TypeSpec); ok {
					if st, ok := ts.Type.(*ast.StructType); ok {
						structType = st
						return false
					}
				}
				return true
			})

			if structType == nil {
				t.Fatal("Could not find struct in AST")
			}

			flags := sp.constructorFlags(structType)

			if flags.Visibility != test.visibility {
				t.Errorf("Visibility = %v, expected %v", flags.Visibility, test.visibility)
			}
			if flags.ProcessStruct != test.process {
				t.Errorf("ProcessStruct = %v, expected %v", flags.ProcessStruct, test.process)
			}
		})
	}
}

// TestConstructorFlagsFromField tests parsing constructor flags from field comments
func TestConstructorFlagsFromField(t *testing.T) {
	src := `
package test

type TestStruct struct {
	Config struct { //+gob:Constructor
		host string
	}

	Settings *struct { //+gob:constructor
		theme string
	}

	NoBuilder struct { // No constructor annotation
		value string
	}
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", src, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse source: %v", err)
	}

	sp := NewStructParser(fset, []byte(src))

	// Find the TestStruct
	var testStruct *ast.StructType
	ast.Inspect(file, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok && ts.Name.Name == "TestStruct" {
			if st, ok := ts.Type.(*ast.StructType); ok {
				testStruct = st
				return false
			}
		}
		return true
	})

	if testStruct == nil {
		t.Fatalf("Could not find TestStruct")
	}

	// Test each field
	for _, field := range testStruct.Fields.List {
		for _, name := range field.Names {
			flags := sp.constructorFlagsFromField(field)

			switch name.Name {
			case "Config":
				if !flags.ProcessStruct {
					t.Errorf("Expected Config field to have ProcessStruct=true")
				}
				if flags.Visibility != ExportedVisibility {
					t.Errorf("Expected Config field to have ExportedVisibility")
				}
			case "Settings":
				if !flags.ProcessStruct {
					t.Errorf("Expected Settings field to have ProcessStruct=true")
				}
				if flags.Visibility != PackageLevelVisibility {
					t.Errorf("Expected Settings field to have PackageLevelVisibility")
				}
			case "NoBuilder":
				if flags.ProcessStruct {
					t.Errorf("Expected NoBuilder field to have ProcessStruct=false")
				}
			}
		}
	}
}

// TestBuildStructTypeStringWithTags tests struct type string generation with tags
func TestBuildStructTypeStringWithTags(t *testing.T) {
	src := `
package test

type TestStruct struct {
	Config struct {
		host    string ` + "`json:\"host\"`" + `
		port    int    ` + "`json:\"port\"`" + `
		timeout int
	}
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", src, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse source: %v", err)
	}

	// Find the Config struct
	var configStruct *ast.StructType
	ast.Inspect(file, func(n ast.Node) bool {
		if field, ok := n.(*ast.Field); ok {
			if len(field.Names) > 0 && field.Names[0].Name == "Config" {
				if st, ok := field.Type.(*ast.StructType); ok {
					configStruct = st
					return false
				}
			}
		}
		return true
	})

	if configStruct == nil {
		t.Fatalf("Could not find Config struct")
	}

	// Test struct type string generation
	formatter := newDefaultTypeFormatter()
	result := buildStructTypeStringFromAST(configStruct, formatter)

	// Verify struct tags are preserved
	if !strings.Contains(result, `json:"host"`) {
		t.Errorf("Expected struct tag json:\"host\" to be preserved in result: %s", result)
	}
	if !strings.Contains(result, `json:"port"`) {
		t.Errorf("Expected struct tag json:\"port\" to be preserved in result: %s", result)
	}
	if !strings.Contains(result, "timeout int") {
		t.Errorf("Expected field without tag to be included: %s", result)
	}
}

// TestInlineInterfaceSupport tests that inline interfaces are handled correctly
func TestInlineInterfaceSupport(t *testing.T) {
	src := `
package test

type StructWithInterface struct { //+gob:Constructor
	name string
	handler interface {
		Process(string) error
		Close() error
	}
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", src, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse source: %v", err)
	}

	sp := NewStructParser(fset, []byte(src))

	// Find the StructWithInterface
	var structType *ast.StructType
	ast.Inspect(file, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok && ts.Name.Name == "StructWithInterface" {
			if st, ok := ts.Type.(*ast.StructType); ok {
				structType = st
				return false
			}
		}
		return true
	})

	if structType == nil {
		t.Fatalf("Could not find StructWithInterface")
	}

	// Test that inline interface fields are processed correctly
	for _, field := range structType.Fields.List {
		for _, name := range field.Names {
			if name.Name == "handler" {
				// Check that it's recognized as an interface type
				if _, ok := field.Type.(*ast.InterfaceType); !ok {
					t.Errorf("Expected handler field to be interface type, got %T", field.Type)
				}

				// Test field type text generation
				fieldTypeText := sp.fieldTypeText(field)
				if !strings.Contains(fieldTypeText, "interface") {
					t.Errorf("Expected field type to contain 'interface', got: %s", fieldTypeText)
				}
				if !strings.Contains(fieldTypeText, "Process(string) error") {
					t.Errorf("Expected field type to contain method signature, got: %s", fieldTypeText)
				}
			}
		}
	}
}

// TestComplexInlineInterfaces tests various inline interface scenarios
func TestComplexInlineInterfaces(t *testing.T) {
	src := `
package test

import "io"

type ComplexStruct struct { //+gob:Constructor
	// Empty interface
	any interface{}

	// Single method interface
	logger interface {
		Log(string)
	}

	// Multi-method interface
	processor interface {
		Process([]byte) (int, error)
		Validate() bool
		Close() error
	}

	// Standard library interface
	reader io.Reader

	// Nested inline interface
	service interface {
		Handle(interface {
			GetID() string
		}) error
	}
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", src, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse source: %v", err)
	}

	sp := NewStructParser(fset, []byte(src))

	// Find the ComplexStruct
	var structType *ast.StructType
	ast.Inspect(file, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok && ts.Name.Name == "ComplexStruct" {
			if st, ok := ts.Type.(*ast.StructType); ok {
				structType = st
				return false
			}
		}
		return true
	})

	if structType == nil {
		t.Fatalf("Could not find ComplexStruct")
	}

	testCases := map[string]struct {
		shouldBeInterface bool
		expectedContent   []string
	}{
		"any": {
			shouldBeInterface: true,
			expectedContent:   []string{"interface{}"},
		},
		"logger": {
			shouldBeInterface: true,
			expectedContent:   []string{"interface", "Log(string)"},
		},
		"processor": {
			shouldBeInterface: true,
			expectedContent:   []string{"interface", "Process([]byte) (int, error)", "Validate() bool", "Close() error"},
		},
		"reader": {
			shouldBeInterface: false,
			expectedContent:   []string{"io.Reader"},
		},
		"service": {
			shouldBeInterface: true,
			expectedContent:   []string{"interface", "Handle(", "GetID() string"},
		},
	}

	// Test each field
	for _, field := range structType.Fields.List {
		for _, name := range field.Names {
			testCase, exists := testCases[name.Name]
			if !exists {
				continue
			}

			// Check interface type detection
			_, isInterface := field.Type.(*ast.InterfaceType)
			if isInterface != testCase.shouldBeInterface {
				t.Errorf("Field %s: expected interface=%v, got %v", name.Name, testCase.shouldBeInterface, isInterface)
			}

			// Test field type text generation
			fieldTypeText := sp.fieldTypeText(field)
			for _, expectedContent := range testCase.expectedContent {
				if !strings.Contains(fieldTypeText, expectedContent) {
					t.Errorf("Field %s: expected field type to contain '%s', got: %s", name.Name, expectedContent, fieldTypeText)
				}
			}
		}
	}
}

// TestGetterAnnotationValidation tests that getter annotations are only allowed on lowercase fields
func TestGetterAnnotationValidation(t *testing.T) {
	testCases := []struct {
		name        string
		source      string
		shouldError bool
		errorMsg    string
	}{
		{
			name: "Valid lowercase field with getter",
			source: `
package test

type ValidStruct struct { //+gob:Constructor
	name string //+gob:getter
	age  int
}
`,
			shouldError: false,
		},
		{
			name: "Invalid uppercase field with getter",
			source: `
package test

type InvalidStruct struct { //+gob:Constructor
	Name string //+gob:getter
	Age  int
}
`,
			shouldError: true,
			errorMsg:    "field 'Name' in struct 'InvalidStruct' has //+gob:getter annotation but starts with uppercase",
		},
		{
			name: "Multiple fields - mixed valid and invalid",
			source: `
package test

type MixedStruct struct { //+gob:Constructor
	name string //+gob:getter  // Valid
	Age  int    //+gob:getter  // Invalid
}
`,
			shouldError: true,
			errorMsg:    "field 'Age' in struct 'MixedStruct' has //+gob:getter annotation but starts with uppercase",
		},
		{
			name: "Uppercase field without getter (should be fine)",
			source: `
package test

type UppercaseStruct struct { //+gob:Constructor
	Name string  // No getter annotation - this is fine
	Age  int
}
`,
			shouldError: false,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Create temporary file
			tempFile, err := os.CreateTemp("", "test_*.go")
			if err != nil {
				t.Fatalf("Failed to create temp file: %v", err)
			}
			defer os.Remove(tempFile.Name())

			if _, err := tempFile.WriteString(tc.source); err != nil {
				t.Fatalf("Failed to write to temp file: %v", err)
			}
			tempFile.Close()

			// Create config
			config := &Config{
				InputPath:             tempFile.Name(),
				GenerateFor:           nil,
				ConstructorVisibility: ConstructorExported,
			}

			// Test generateCodeForFile
			outputFile := makeOutputFilename(tempFile.Name())
			defer os.Remove(outputFile) // Clean up output file

			err = generateCodeForFile(tempFile.Name(), outputFile, config)

			if tc.shouldError {
				if err == nil {
					t.Errorf("Expected error but got none")
				} else if !strings.Contains(err.Error(), tc.errorMsg) {
					t.Errorf("Expected error message to contain '%s', got: %s", tc.errorMsg, err.Error())
				} else if !strings.Contains(err.Error(), tempFile.Name()) {
					t.Errorf("Expected error message to include file path '%s', got: %s", tempFile.Name(), err.Error())
				}
			} else {
				if err != nil {
					t.Errorf("Expected no error but got: %v", err)
				}
			}
		})
	}
}

// TestFindGoFiles tests the findGoFiles function
func TestFindGoFiles(t *testing.T) {
	// Create a temporary directory structure for testing
	tempDir := t.TempDir()

	// Create test files
	testFiles := map[string]string{
		"models.go":                  "package test\ntype User struct{}",
		"subdir/orders.go":           "package subdir\ntype Order struct{}",
		"subdir/nested/inventory.go": "package nested\ntype Item struct{}",
		"models_test.go":             "package test\nfunc TestUser(t *testing.T) {}",
		"existing_gob.go":            "package test\n// Generated file",
		"subdir/orders_gob.go":       "package subdir\n// Generated file",
		"README.md":                  "# Documentation",
		"config.json":                `{"key": "value"}`,
	}

	for filePath, content := range testFiles {
		fullPath := filepath.Join(tempDir, filePath)
		dir := filepath.Dir(fullPath)
		if err := os.MkdirAll(dir, 0755); err != nil {
			t.Fatalf("Failed to create directory %s: %v", dir, err)
		}
		if err := os.WriteFile(fullPath, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create test file %s: %v", fullPath, err)
		}
	}

	// Test findGoFiles
	goFiles, err := findGoFiles(tempDir)
	if err != nil {
		t.Fatalf("findGoFiles failed: %v", err)
	}

	// Expected files (should exclude test files and _gob files)
	expectedFiles := []string{
		filepath.Join(tempDir, "models.go"),
		filepath.Join(tempDir, "subdir", "orders.go"),
		filepath.Join(tempDir, "subdir", "nested", "inventory.go"),
	}

	if len(goFiles) != len(expectedFiles) {
		t.Errorf("Expected %d files, got %d", len(expectedFiles), len(goFiles))
	}

	// Convert to sets for comparison
	expectedSet := make(map[string]bool)
	for _, f := range expectedFiles {
		expectedSet[f] = true
	}

	foundSet := make(map[string]bool)
	for _, f := range goFiles {
		foundSet[f] = true
	}

	for expected := range expectedSet {
		if !foundSet[expected] {
			t.Errorf("Expected file not found: %s", expected)
		}
	}

	for found := range foundSet {
		if !expectedSet[found] {
			t.Errorf("Unexpected file found: %s", found)
		}
	}
}
