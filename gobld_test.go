package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"strings"
	"testing"
)

func TestGeneratePackage(t *testing.T) {
	// Create a simple AST file for testing
	fset := token.NewFileSet()
	src := "package testpkg\n"
	astFile, err := parser.ParseFile(fset, "test.go", src, 0)
	if err != nil {
		t.Fatal(err)
	}

	result := GeneratePackage(astFile)
	expected := "// Code generated by gobetter; DO NOT EDIT.\n\npackage testpkg\n\n"

	if result != expected {
		t.Errorf("GeneratePackage() = %q, expected %q", result, expected)
	}
}

func TestGenerateImports(t *testing.T) {
	tests := []struct {
		name     string
		src      string
		expected string
	}{
		{
			name:     "no imports",
			src:      "package test\n",
			expected: "",
		},
		{
			name:     "single import",
			src:      "package test\nimport \"fmt\"\n",
			expected: "import (\n\t\"fmt\"\n)\n\n",
		},
		{
			name:     "multiple imports",
			src:      "package test\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n",
			expected: "import (\n\t\"fmt\"\n\t\"strings\"\n)\n\n",
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			fset := token.NewFileSet()
			astFile, err := parser.ParseFile(fset, "test.go", test.src, parser.ParseComments)
			if err != nil {
				t.Fatal(err)
			}

			result := GenerateImports(astFile)
			if result != test.expected {
				t.Errorf("GenerateImports() = %q, expected %q", result, test.expected)
			}
		})
	}
}

func TestStructFieldGenerateGetter(t *testing.T) {
	tests := []struct {
		name      string
		fieldName string
		fieldType string
		acronym   bool
		expected  string
	}{
		{
			name:      "regular field",
			fieldName: "firstName",
			fieldType: "string",
			acronym:   false,
			expected:  "FirstName",
		},
		{
			name:      "acronym field",
			fieldName: "dob",
			fieldType: "string",
			acronym:   true,
			expected:  "DOB",
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			sf := &StructField{
				StructName:    "Person",
				FieldName:     test.fieldName,
				FieldTypeText: test.fieldType,
				Acronym:       test.acronym,
			}

			result := sf.GenerateGetter()

			if !strings.Contains(result, test.expected+"()") {
				t.Errorf("GenerateGetter() does not contain expected method name %q", test.expected+"()")
			}
			if !strings.Contains(result, test.fieldType) {
				t.Errorf("GenerateGetter() does not contain expected return type %q", test.fieldType)
			}
			if !strings.Contains(result, "return v."+test.fieldName) {
				t.Errorf("GenerateGetter() does not contain expected return statement")
			}
		})
	}
}

func TestStructFieldBuilderFieldStructName(t *testing.T) {
	tests := []struct {
		name       string
		structName string
		fieldName  string
		acronym    bool
		expected   string
	}{
		{
			name:       "regular field",
			structName: "Person",
			fieldName:  "firstName",
			acronym:    false,
			expected:   "Person_Builder_FirstName",
		},
		{
			name:       "acronym field",
			structName: "Person",
			fieldName:  "dob",
			acronym:    true,
			expected:   "Person_Builder_DOB",
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			sf := &StructField{
				StructName: test.structName,
				FieldName:  test.fieldName,
				Acronym:    test.acronym,
			}

			result := sf.builderFieldStructName()
			if result != test.expected {
				t.Errorf("builderFieldStructName() = %q, expected %q", result, test.expected)
			}
		})
	}
}

func TestNewStructParser(t *testing.T) {
	fset := token.NewFileSet()
	content := []byte("test content")

	parser := NewStructParser(fset, content)

	if parser.fileSet != fset {
		t.Error("fileSet not set correctly")
	}
	if string(parser.fileContent) != string(content) {
		t.Error("fileContent not set correctly")
	}
	// titleCaser is a value type, so we can't check for nil
	// Just verify it works by using it
	testResult := parser.titleCaser.String("test")
	if testResult != "Test" {
		t.Error("titleCaser not working correctly")
	}
}

func TestStructParserFieldMethods(t *testing.T) {
	src := `package test

type Person struct {
	firstName string //+gob:getter
	lastName  string //+gob:getter +gob:acronym
	age       int    //+gob:_
	email     string
}`

	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, "test.go", src, parser.ParseComments)
	if err != nil {
		t.Fatal(err)
	}

	sp := NewStructParser(fset, []byte(src))

	// Find the struct
	var structType *ast.StructType
	ast.Inspect(astFile, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok {
			if st, ok := ts.Type.(*ast.StructType); ok {
				structType = st
				return false
			}
		}
		return true
	})

	if structType == nil {
		t.Fatal("Could not find struct in AST")
	}

	tests := []struct {
		fieldIndex int
		getter     bool
		optional   bool
		acronym    bool
	}{
		{0, true, false, false},  // firstName
		{1, true, false, true},   // lastName
		{2, false, true, false},  // age
		{3, false, false, false}, // email
	}

	for i, test := range tests {
		field := structType.Fields.List[i]

		if sp.fieldGetter(field) != test.getter {
			t.Errorf("Field %d: fieldGetter() = %v, expected %v", i, sp.fieldGetter(field), test.getter)
		}
		if sp.fieldOptional(field) != test.optional {
			t.Errorf("Field %d: fieldOptional() = %v, expected %v", i, sp.fieldOptional(field), test.optional)
		}
		if sp.fieldAcronym(field) != test.acronym {
			t.Errorf("Field %d: fieldAcronym() = %v, expected %v", i, sp.fieldAcronym(field), test.acronym)
		}
	}
}

// TestFindAllStructs tests the discovery of nested structs
func TestFindAllStructs(t *testing.T) {
	src := `
package test

type OuterStruct struct {
	name string

	Config struct { //+gob:Constructor
		host string //+gob:getter
		port int

		Database struct { //+gob:Constructor
			driver string //+gob:getter
			host   string
		}
	}

	Settings *struct { //+gob:Constructor
		theme string //+gob:getter
	}
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", src, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse source: %v", err)
	}

	structs := findAllStructs(file, "")

	// Should find: OuterStruct, OuterStructConfig, OuterStructConfigDatabase, OuterStructSettings
	expectedStructs := []string{
		"OuterStruct",
		"OuterStructConfig",
		"OuterStructConfigDatabase",
		"OuterStructSettings",
	}

	if len(structs) != len(expectedStructs) {
		t.Errorf("Expected %d structs, got %d", len(expectedStructs), len(structs))
	}

	structNames := make(map[string]bool)
	for _, s := range structs {
		structNames[s.Name] = true
	}

	for _, expected := range expectedStructs {
		if !structNames[expected] {
			t.Errorf("Expected to find struct '%s', but it was not found", expected)
		}
	}

	// Test that top-level struct has TypeSpec
	for _, s := range structs {
		if s.Name == "OuterStruct" {
			if s.TypeSpec == nil {
				t.Errorf("Expected OuterStruct to have TypeSpec (top-level struct)")
			}
		} else {
			if s.TypeSpec != nil {
				t.Errorf("Expected %s to not have TypeSpec (inner struct)", s.Name)
			}
		}
	}
}

func TestStructParserConstructorFlags(t *testing.T) {
	tests := []struct {
		name       string
		src        string
		visibility Visibility
		process    bool
	}{
		{
			name:       "exported constructor",
			src:        "type Person struct { //+gob:Constructor\n}",
			visibility: ExportedVisibility,
			process:    true,
		},
		{
			name:       "package constructor",
			src:        "type Person struct { //+gob:constructor\n}",
			visibility: PackageLevelVisibility,
			process:    true,
		},
		{
			name:       "no constructor",
			src:        "type Person struct { //+gob:_\n}",
			visibility: NoVisibility,
			process:    true,
		},
		{
			name:       "no annotation",
			src:        "type Person struct {\n}",
			visibility: ExportedVisibility,
			process:    false,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			fullSrc := "package test\n" + test.src
			fset := token.NewFileSet()
			astFile, err := parser.ParseFile(fset, "test.go", fullSrc, parser.ParseComments)
			if err != nil {
				t.Fatal(err)
			}

			sp := NewStructParser(fset, []byte(fullSrc))

			var structType *ast.StructType
			ast.Inspect(astFile, func(n ast.Node) bool {
				if ts, ok := n.(*ast.TypeSpec); ok {
					if st, ok := ts.Type.(*ast.StructType); ok {
						structType = st
						return false
					}
				}
				return true
			})

			if structType == nil {
				t.Fatal("Could not find struct in AST")
			}

			flags := sp.constructorFlags(structType)

			if flags.Visibility != test.visibility {
				t.Errorf("Visibility = %v, expected %v", flags.Visibility, test.visibility)
			}
			if flags.ProcessStruct != test.process {
				t.Errorf("ProcessStruct = %v, expected %v", flags.ProcessStruct, test.process)
			}
		})
	}
}

// TestConstructorFlagsFromField tests parsing constructor flags from field comments
func TestConstructorFlagsFromField(t *testing.T) {
	src := `
package test

type TestStruct struct {
	Config struct { //+gob:Constructor
		host string
	}

	Settings *struct { //+gob:constructor
		theme string
	}

	NoBuilder struct { // No constructor annotation
		value string
	}
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", src, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse source: %v", err)
	}

	sp := NewStructParser(fset, []byte(src))

	// Find the TestStruct
	var testStruct *ast.StructType
	ast.Inspect(file, func(n ast.Node) bool {
		if ts, ok := n.(*ast.TypeSpec); ok && ts.Name.Name == "TestStruct" {
			if st, ok := ts.Type.(*ast.StructType); ok {
				testStruct = st
				return false
			}
		}
		return true
	})

	if testStruct == nil {
		t.Fatalf("Could not find TestStruct")
	}

	// Test each field
	for _, field := range testStruct.Fields.List {
		for _, name := range field.Names {
			flags := sp.constructorFlagsFromField(field)

			switch name.Name {
			case "Config":
				if !flags.ProcessStruct {
					t.Errorf("Expected Config field to have ProcessStruct=true")
				}
				if flags.Visibility != ExportedVisibility {
					t.Errorf("Expected Config field to have ExportedVisibility")
				}
			case "Settings":
				if !flags.ProcessStruct {
					t.Errorf("Expected Settings field to have ProcessStruct=true")
				}
				if flags.Visibility != PackageLevelVisibility {
					t.Errorf("Expected Settings field to have PackageLevelVisibility")
				}
			case "NoBuilder":
				if flags.ProcessStruct {
					t.Errorf("Expected NoBuilder field to have ProcessStruct=false")
				}
			}
		}
	}
}

// TestBuildStructTypeStringWithTags tests struct type string generation with tags
func TestBuildStructTypeStringWithTags(t *testing.T) {
	src := `
package test

type TestStruct struct {
	Config struct {
		host    string ` + "`json:\"host\"`" + `
		port    int    ` + "`json:\"port\"`" + `
		timeout int
	}
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", src, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse source: %v", err)
	}

	// Find the Config struct
	var configStruct *ast.StructType
	ast.Inspect(file, func(n ast.Node) bool {
		if field, ok := n.(*ast.Field); ok {
			if len(field.Names) > 0 && field.Names[0].Name == "Config" {
				if st, ok := field.Type.(*ast.StructType); ok {
					configStruct = st
					return false
				}
			}
		}
		return true
	})

	if configStruct == nil {
		t.Fatalf("Could not find Config struct")
	}

	// Test struct type string generation
	structs := findAllStructs(file, "")
	result := buildStructTypeStringFromAST(configStruct, structs)

	// Verify struct tags are preserved
	if !strings.Contains(result, `json:"host"`) {
		t.Errorf("Expected struct tag json:\"host\" to be preserved in result: %s", result)
	}
	if !strings.Contains(result, `json:"port"`) {
		t.Errorf("Expected struct tag json:\"port\" to be preserved in result: %s", result)
	}
	if !strings.Contains(result, "timeout int") {
		t.Errorf("Expected field without tag to be included: %s", result)
	}
}
