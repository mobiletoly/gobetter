package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"strings"
	"unicode"
	"unicode/utf8"
)

type Visibility int

const (
	ExportedVisibility Visibility = iota
	PackageLevelVisibility
	NoVisibility
)

// StructParser handles parsing of Go struct definitions and their annotations
type StructParser struct {
	fileSet     *token.FileSet
	fileContent []byte
}

// StructField represents a field in a struct that needs builder generation
type StructField struct {
	StructFlags   *StructFlags
	StructName    string
	FieldName     string
	FieldTypeText string
	Acronym       bool
}

// StructFlags contains configuration flags for struct processing
type StructFlags struct {
	ProcessStruct bool
	Visibility    Visibility
}

// GeneratePackage generates the package declaration for the output file
func GeneratePackage(astFile *ast.File) string {
	var bld strings.Builder
	bld.WriteString("// Code generated by gobetter; DO NOT EDIT.\n\n")
	bld.WriteString(fmt.Sprintf("package %s\n\n", astFile.Name.Name))
	return bld.String()
}

// GenerateGetter generates a getter method for a struct field
func (sf *StructField) GenerateGetter() string {
	methodName := exportName(sf.FieldName, sf.Acronym)

	// Default to pointer receiver for backward compatibility unless explicitly set to value.
	receiverType := "*" + sf.StructName
	return fmt.Sprintf(`
func (v %s) %s() %s {
	return v.%s
}

`, receiverType, methodName, sf.FieldTypeText, sf.FieldName)
}

// GenerateSourceCodeForStructField generates the builder code for a struct field
func (sf *StructField) GenerateSourceCodeForStructField(prev *StructField, last bool) string {
	var bld strings.Builder

	if prev == nil {
		sf.generateConstructor(&bld)
	}
	sf.generateBuilderStruct(&bld)
	if prev != nil {
		sf.generateBuilderSetter(&bld, prev)
	}
	if last {
		finalSf := StructField{
			StructFlags:   sf.StructFlags,
			StructName:    sf.StructName,
			FieldName:     GobFinalizerName,
			FieldTypeText: "PLACEHOLDER", // This value is not used in the final output
			Acronym:       false,
		}
		finalSf.generateBuilderStruct(&bld)
		finalSf.generateBuilderSetter(&bld, sf)
		finalSf.generateBuildFunction(&bld)
	}
	return bld.String()
}

// generateBuildFunction generates the final Build() method
func (sf *StructField) generateBuildFunction(bld *strings.Builder) {
	builderStructName := sf.builderFieldStructName()
	bld.WriteString(fmt.Sprintf(`
func (b %s) %s() *%s {
	return b.root
}

`, builderStructName, BuildMethodName, sf.StructName))
}

// generateBuilderStruct generates a builder struct type
func (sf *StructField) generateBuilderStruct(bld *strings.Builder) {
	builderStructName := sf.builderFieldStructName()
	bld.WriteString(fmt.Sprintf(`
type %s struct {
	root *%s
}

`, builderStructName, sf.StructName))
}

// generateBuilderSetter generates a setter method for the builder
func (sf *StructField) generateBuilderSetter(bld *strings.Builder, prev *StructField) {
	setterName := exportName(prev.FieldName, prev.Acronym)
	prevBuilderStructName := prev.builderFieldStructName()
	builderStructName := sf.builderFieldStructName()
	bld.WriteString(fmt.Sprintf(`
func (b %s) %s(arg %s) %s {
	b.root.%s = arg
	return %s{root: b.root}
}

`, prevBuilderStructName, setterName, prev.FieldTypeText, builderStructName,
		prev.FieldName, builderStructName))
}

// generateConstructor generates the constructor function for the builder
func (sf *StructField) generateConstructor(bld *strings.Builder) {
	builderStructName := sf.builderFieldStructName()

	var funcName string
	firstChar := rune(sf.StructName[0])
	if unicode.IsLower(firstChar) || sf.StructFlags.Visibility == PackageLevelVisibility {
		funcName = LowerNewPrefix + upperFirstASCIIOrUnicode(sf.StructName)
	} else {
		funcName = NewPrefix + upperFirstASCIIOrUnicode(sf.StructName)
	}

	bld.WriteString(fmt.Sprintf(`
func %s%s() %s {
	return %s{root: &%s{}}
}

`, funcName, BuilderSuffix, builderStructName, builderStructName, sf.StructName))
}

// builderFieldStructName generates the name for a builder struct
func (sf *StructField) builderFieldStructName() string {
	return sf.StructName + BuilderPrefix + exportName(sf.FieldName, sf.Acronym)
}

// NewStructParser creates a new StructParser instance
func NewStructParser(fileSet *token.FileSet, fileContent []byte) StructParser {
	return StructParser{
		fileSet:     fileSet,
		fileContent: fileContent,
	}
}

// fieldTypeText extracts the type text for a field using the AST pretty-printer,
// ensuring valid Go syntax (e.g., semicolons between interface methods).
func (sp *StructParser) fieldTypeText(field *ast.Field) string {
	if field == nil || field.Type == nil {
		return ""
	}
	return sp.getFieldTypeFromAST(field.Type)
}

// fieldCommentText returns all comments relevant to a field:
// - trailing line comment (inline, same line as the field)
// - field.Comment (trailing comment group)
// - field.Doc (leading doc comment group)
func (sp *StructParser) fieldCommentText(field *ast.Field) string {
	if field == nil {
		return ""
	}

	var b strings.Builder
	if field.Comment != nil {
		b.WriteString(field.Comment.Text())
	}
	if field.Doc != nil {
		b.WriteString(field.Doc.Text())
	}

	// Add inline comment on the same line as the field declaration, if present.
	begin := field.Pos()
	file := sp.fileSet.File(begin)
	if file == nil {
		return b.String()
	}
	line := sp.fileSet.Position(begin).Line
	lineStart := file.LineStart(line)

	var lineEnd token.Pos
	if line < file.LineCount() {
		lineEnd = file.LineStart(line+1) - 1
	} else {
		lineEnd = token.Pos(len(sp.fileContent))
	}

	startOffset := sp.fileSet.Position(lineStart).Offset
	endOffset := sp.fileSet.Position(lineEnd).Offset

	if startOffset >= 0 && endOffset >= 0 && startOffset < endOffset && endOffset <= len(sp.fileContent) {
		lineContent := string(sp.fileContent[startOffset:endOffset])
		if idx := strings.Index(lineContent, "//"); idx != -1 {
			b.WriteString(lineContent[idx:])
		}
	}

	return b.String()
}

// fieldOptional checks if a field is marked as optional
func (sp *StructParser) fieldOptional(field *ast.Field) bool {
	return FlagOptionalRegexp.MatchString(sp.fieldCommentText(field))
}

// fieldGetter checks if a field should have a getter generated
func (sp *StructParser) fieldGetter(field *ast.Field) bool {
	return FlagGetterRegexp.MatchString(sp.fieldCommentText(field))
}

// fieldAcronym checks if a field is marked as an acronym
func (sp *StructParser) fieldAcronym(field *ast.Field) bool {
	return FlagAcronymRegexp.MatchString(sp.fieldCommentText(field))
}

// constructorFlags parses constructor flags from the type line and any contiguous
// doc comments immediately above it. We intentionally work from the StructType's
// `struct` token position and walk the file lines using fileSet, so we don't
// require the caller to pass *ast.TypeSpec or *ast.GenDecl.
func (sp *StructParser) constructorFlags(st *ast.StructType) StructFlags {
	flags := StructFlags{
		ProcessStruct: false,
		Visibility:    ExportedVisibility,
	}

	begin := st.Struct
	file := sp.fileSet.File(begin)
	if file == nil {
		return flags
	}

	// Line containing the `struct` keyword (usually the `type ... struct {` line)
	line := file.Line(begin)

	// Helper to fetch raw bytes for a given 1-based line number.
	getLine := func(ln int) string {
		if ln < 1 || ln > file.LineCount() {
			return ""
		}
		start := file.LineStart(ln)
		var end token.Pos
		if ln < file.LineCount() {
			end = file.LineStart(ln+1) - 1
		} else {
			end = token.Pos(len(sp.fileContent))
		}
		startOffset := sp.fileSet.Position(start).Offset
		endOffset := sp.fileSet.Position(end).Offset
		if startOffset < 0 || endOffset < 0 || startOffset > len(sp.fileContent) || endOffset > len(sp.fileContent) || startOffset >= endOffset {
			return ""
		}
		return string(sp.fileContent[startOffset:endOffset])
	}

	var builder strings.Builder

	// 1) Inline comment on the type line (same line as `struct`).
	typeLine := getLine(line)
	if idx := strings.Index(typeLine, "//"); idx != -1 {
		builder.WriteString(typeLine[idx:])
		builder.WriteString("\n")
	}

	// 2) Contiguous doc comment block immediately above (lines starting with //).
	for ln := line - 1; ln >= 1; ln-- {
		txt := strings.TrimSpace(getLine(ln))
		if txt == "" {
			// Blank lines break a Go doc comment group; stop collecting.
			break
		}
		if strings.HasPrefix(txt, "//") {
			// Prepend to preserve natural order.
			builder.WriteString(txt)
			builder.WriteString("\n")
			continue
		}
		// Non-comment code or other text stops the doc comment block.
		break
	}

	commentText := builder.String()

	if ConstructorPackageRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = PackageLevelVisibility
	} else if ConstructorExportedRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = ExportedVisibility
	} else if ConstructorNoRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = NoVisibility
	}

	return flags
}

// constructorFlagsFromField parses constructor flags from field comments for inner structs
func (sp *StructParser) constructorFlagsFromField(field *ast.Field) StructFlags {
	flags := StructFlags{
		ProcessStruct: false,
		Visibility:    ExportedVisibility,
	}
	if field == nil {
		return flags
	}
	commentText := sp.fieldCommentText(field)

	if ConstructorPackageRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = PackageLevelVisibility
	} else if ConstructorExportedRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = ExportedVisibility
	} else if ConstructorNoRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = NoVisibility
	}
	return flags
}

// getInnerStructFieldType extracts the type for inner struct fields
func (sp *StructParser) getInnerStructFieldType(field *ast.Field, parentStructName string) string {
	// Handle both direct struct types and pointer to struct types
	switch t := field.Type.(type) {
	case *ast.StructType:
		// Direct struct type: struct { ... }
		return sp.buildStructTypeString(t)
	case *ast.StarExpr:
		// Pointer to struct type: *struct { ... }
		if structType, ok := t.X.(*ast.StructType); ok {
			return "*" + sp.buildStructTypeString(structType)
		}
	}

	return "struct{}" // Fallback
}

// getInnerStructFieldTypeWithAlias gets the field type for inner structs, using type alias if available
func (sp *StructParser) getInnerStructFieldTypeWithAlias(field *ast.Field, parentStructName string, allStructs []*StructInfo, config *Config) string {
	// Check if we have a generated type alias for this inner struct
	for _, fieldName := range field.Names {
		expectedTypeName := parentStructName + fieldName.Name

		// Look for this type in the allStructs list
		for _, structInfo := range allStructs {
			if structInfo.Name == expectedTypeName && structInfo.TypeSpec == nil {
				// This is an inner struct - check if it has constructor annotation OR
				// if it should be processed due to -generate-for=exported
				shouldHaveTypeAlias := false

				if structInfo.Field != nil {
					flags := sp.constructorFlagsFromField(structInfo.Field)
					if flags.ProcessStruct {
						shouldHaveTypeAlias = true
					} else if config.GenerateFor != nil && *config.GenerateFor == GenerateForExported {
						// Check if the field is exported (for -generate-for=exported)
						if unicode.IsUpper(rune(fieldName.Name[0])) {
							shouldHaveTypeAlias = true
						}
					}
				}

				if shouldHaveTypeAlias {
					// We have a type alias for this inner struct
					switch field.Type.(type) {
					case *ast.StructType:
						return expectedTypeName
					case *ast.StarExpr:
						return "*" + expectedTypeName
					}
				}
			}
		}
	}

	// No type alias available, fall back to inline struct type
	return sp.getInnerStructFieldType(field, parentStructName)
}

// buildStructTypeString builds a struct type string from AST
func (sp *StructParser) buildStructTypeString(st *ast.StructType) string {
	var fieldParts []string

	for _, field := range st.Fields.List {
		fieldType := sp.getFieldTypeFromAST(field.Type)

		// Extract struct tag if present
		var tag string
		if field.Tag != nil {
			tag = " " + field.Tag.Value // field.Tag.Value includes the backticks
		}

		// Embedded field: field.Names == nil or len == 0
		if len(field.Names) == 0 {
			fieldParts = append(fieldParts, fmt.Sprintf("%s%s", fieldType, tag))
			continue
		}

		// Named field(s)
		for _, name := range field.Names {
			// Use the original field name (don't capitalize) to match the struct definition
			fieldParts = append(fieldParts, fmt.Sprintf("%s %s%s", name.Name, fieldType, tag))
		}
	}

	if len(fieldParts) == 0 {
		return "struct{}"
	}
	// Join fields with semicolons and wrap in struct { }
	return fmt.Sprintf("struct { %s }", strings.Join(fieldParts, "; "))
}

// getFieldTypeFromAST extracts field type from AST node
func (sp *StructParser) getFieldTypeFromAST(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + sp.getFieldTypeFromAST(t.X)
	case *ast.ArrayType:
		return "[]" + sp.getFieldTypeFromAST(t.Elt)
	case *ast.MapType:
		keyType := sp.getFieldTypeFromAST(t.Key)
		valueType := sp.getFieldTypeFromAST(t.Value)
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	case *ast.SelectorExpr:
		pkg := sp.getFieldTypeFromAST(t.X)
		return fmt.Sprintf("%s.%s", pkg, t.Sel.Name)
	case *ast.InterfaceType:
		// Empty interface
		if t.Methods == nil || len(t.Methods.List) == 0 {
			return "interface{}"
		}

		// Non-empty interface: render method set (and embedded interfaces)
		var parts []string
		for _, m := range t.Methods.List {
			// Embedded interface or type term (no name)
			if len(m.Names) == 0 {
				parts = append(parts, sp.getFieldTypeFromAST(m.Type))
				continue
			}
			// Method declaration
			if ft, ok := m.Type.(*ast.FuncType); ok {
				params := sp.tupleToString(ft.Params)
				results := sp.resultsToString(ft.Results)
				parts = append(parts, fmt.Sprintf("%s%s%s", m.Names[0].Name, params, results))
				continue
			}
			// Fallback: just the name if we can't parse a signature
			parts = append(parts, m.Names[0].Name)
		}

		// separate specs with semicolons
		return "interface{ " + strings.Join(parts, "; ") + " }"
	default:
		return "interface{}" // Fallback
	}
}

// tupleToString renders a parameter tuple (without names) like "(int, string)".
func (sp *StructParser) tupleToString(fl *ast.FieldList) string {
	if fl == nil || len(fl.List) == 0 {
		return "()"
	}
	var items []string
	for _, f := range fl.List {
		typ := sp.getFieldTypeFromAST(f.Type)
		// When omitting names, duplicate the type for each name, or once if unnamed.
		count := 1
		if n := len(f.Names); n > 0 {
			count = n
		}
		for i := 0; i < count; i++ {
			items = append(items, typ)
		}
	}
	return "(" + strings.Join(items, ", ") + ")"
}

// resultsToString renders a result tuple. For a single unnamed result, it returns " T".
// For multiple results, it returns " (T1, T2)". Names are omitted for brevity and stability.
func (sp *StructParser) resultsToString(fl *ast.FieldList) string {
	if fl == nil || len(fl.List) == 0 {
		return ""
	}
	var items []string
	for _, f := range fl.List {
		typ := sp.getFieldTypeFromAST(f.Type)
		count := 1
		if n := len(f.Names); n > 0 {
			count = n
		}
		for i := 0; i < count; i++ {
			items = append(items, typ)
		}
	}
	if len(items) == 1 {
		return " " + items[0]
	}
	return " (" + strings.Join(items, ", ") + ")"
}

// upperFirstASCIIOrUnicode upper-cases the first character in a string.
func upperFirstASCIIOrUnicode(s string) string {
	if s == "" {
		return s
	}
	r, sz := utf8.DecodeRuneInString(s)
	return strings.ToUpper(string(r)) + s[sz:]
}

// exportName centralizes the decision of how to render a field/method name with acronym flag support.
func exportName(s string, acronym bool) string {
	if acronym {
		return strings.ToUpper(s)
	}
	return upperFirstASCIIOrUnicode(s)
}
