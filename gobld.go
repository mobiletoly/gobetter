package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"strings"
	"unicode"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

type Visibility int

const (
	ExportedVisibility Visibility = iota
	PackageLevelVisibility
	NoVisibility
)

// StructParser handles parsing of Go struct definitions and their annotations
type StructParser struct {
	fileSet     *token.FileSet
	fileContent []byte
	titleCaser  cases.Caser
}

// StructField represents a field in a struct that needs builder generation
type StructField struct {
	StructFlags   *StructFlags
	StructName    string
	FieldName     string
	FieldTypeText string
	Acronym       bool
}

// StructFlags contains configuration flags for struct processing
type StructFlags struct {
	ProcessStruct bool
	PtrReceiver   bool
	Visibility    Visibility
}

// GeneratePackage generates the package declaration for the output file
func GeneratePackage(astFile *ast.File) string {
	var bld strings.Builder
	bld.WriteString("// Code generated by gobetter; DO NOT EDIT.\n\n")
	bld.WriteString(fmt.Sprintf("package %s\n\n", astFile.Name.Name))
	return bld.String()
}

// GenerateImports generates the import statements for the output file
func GenerateImports(astFile *ast.File) string {
	if len(astFile.Imports) == 0 {
		return ""
	}

	var bld strings.Builder
	bld.WriteString("import (\n")
	for _, imp := range astFile.Imports {
		bld.WriteString(fmt.Sprintf("\t%s\n", imp.Path.Value))
	}
	bld.WriteString(")\n\n")
	return bld.String()
}

// GenerateGetter generates a getter method for a struct field
func (sf *StructField) GenerateGetter() string {
	var methodName string
	if sf.Acronym {
		methodName = strings.ToUpper(sf.FieldName)
	} else {
		// Use proper title casing that capitalizes the first letter only
		methodName = strings.ToUpper(sf.FieldName[:1]) + sf.FieldName[1:]
	}
	return fmt.Sprintf(`
func (v *%s) %s() %s {
	return v.%s
}

`, sf.StructName, methodName, sf.FieldTypeText, sf.FieldName)
}

// GenerateSourceCodeForStructField generates the builder code for a struct field
func (sf *StructField) GenerateSourceCodeForStructField(prev *StructField, last bool) string {
	var bld strings.Builder

	if prev == nil {
		sf.generateConstructor(&bld)
	}
	sf.generateBuilderStruct(&bld)
	if prev != nil {
		sf.generateBuilderSetter(&bld, prev)
	}
	if last {
		finalSf := StructField{
			StructFlags:   sf.StructFlags,
			StructName:    sf.StructName,
			FieldName:     GobFinalizerName,
			FieldTypeText: "PLACEHOLDER", // This value is not used in the final output
			Acronym:       false,
		}
		finalSf.generateBuilderStruct(&bld)
		finalSf.generateBuilderSetter(&bld, sf)
		finalSf.generateBuildFunction(&bld)
	}
	return bld.String()
}

// generateBuildFunction generates the final Build() method
func (sf *StructField) generateBuildFunction(bld *strings.Builder) {
	builderStructName := sf.builderFieldStructName()
	bld.WriteString(fmt.Sprintf(`
func (b %s) %s() *%s {
	return b.root
}

`, builderStructName, BuildMethodName, sf.StructName))
}

// generateBuilderStruct generates a builder struct type
func (sf *StructField) generateBuilderStruct(bld *strings.Builder) {
	builderStructName := sf.builderFieldStructName()
	bld.WriteString(fmt.Sprintf(`
type %s struct {
	root *%s
}

`, builderStructName, sf.StructName))
}

// generateBuilderSetter generates a setter method for the builder
func (sf *StructField) generateBuilderSetter(bld *strings.Builder, prev *StructField) {
	var setterName string
	if prev.Acronym {
		setterName = strings.ToUpper(prev.FieldName)
	} else {
		setterName = strings.ToUpper(prev.FieldName[:1]) + prev.FieldName[1:]
	}

	prevBuilderStructName := prev.builderFieldStructName()
	builderStructName := sf.builderFieldStructName()
	bld.WriteString(fmt.Sprintf(`
func (b %s) %s(arg %s) %s {
	b.root.%s = arg
	return %s{root: b.root}
}

`, prevBuilderStructName, setterName, prev.FieldTypeText, builderStructName,
		prev.FieldName, builderStructName))
}

// generateConstructor generates the constructor function for the builder
func (sf *StructField) generateConstructor(bld *strings.Builder) {
	builderStructName := sf.builderFieldStructName()

	var funcName string
	firstChar := rune(sf.StructName[0])
	if unicode.IsLower(firstChar) || sf.StructFlags.Visibility == PackageLevelVisibility {
		funcName = LowerNewPrefix + strings.ToUpper(sf.StructName[:1]) + sf.StructName[1:]
	} else {
		funcName = NewPrefix + strings.ToUpper(sf.StructName[:1]) + sf.StructName[1:]
	}

	bld.WriteString(fmt.Sprintf(`
func %s%s() %s {
	return %s{root: &%s{}}
}

`, funcName, BuilderSuffix, builderStructName, builderStructName, sf.StructName))
}

// builderFieldStructName generates the name for a builder struct
func (sf *StructField) builderFieldStructName() string {
	var title string
	if sf.Acronym {
		title = strings.ToUpper(sf.FieldName)
	} else {
		title = strings.ToUpper(sf.FieldName[:1]) + sf.FieldName[1:]
	}
	return sf.StructName + BuilderPrefix + title
}

// NewStructParser creates a new StructParser instance
func NewStructParser(fileSet *token.FileSet, fileContent []byte) StructParser {
	return StructParser{
		fileSet:     fileSet,
		fileContent: fileContent,
		titleCaser:  cases.Title(language.English),
	}
}

// fieldTypeText extracts the type text for a field
func (sp *StructParser) fieldTypeText(field *ast.Field) string {
	begin := sp.fileSet.Position(field.Type.Pos()).Offset
	end := sp.fileSet.Position(field.Type.End()).Offset
	return WhitespaceRegexp.ReplaceAllString(string(sp.fileContent[begin:end]), " ")
}

// fieldOptional checks if a field is marked as optional
func (sp *StructParser) fieldOptional(field *ast.Field) bool {
	if field.Comment == nil {
		return false
	}
	return FlagOptionalRegexp.MatchString(field.Comment.Text())
}

// fieldGetter checks if a field should have a getter generated
func (sp *StructParser) fieldGetter(field *ast.Field) bool {
	if field.Comment == nil {
		return false
	}
	return FlagGetterRegexp.MatchString(field.Comment.Text())
}

// fieldAcronym checks if a field is marked as an acronym
func (sp *StructParser) fieldAcronym(field *ast.Field) bool {
	if field.Comment == nil {
		return false
	}
	return FlagAcronymRegexp.MatchString(field.Comment.Text())
}

// constructorFlags parses the constructor flags from struct comments
func (sp *StructParser) constructorFlags(st *ast.StructType) StructFlags {
	begin := st.Struct
	endLine := sp.fileSet.File(begin).Line(begin) + 1
	end := sp.fileSet.File(begin).LineStart(endLine)
	result := string(sp.fileContent[sp.fileSet.Position(begin).Offset:sp.fileSet.Position(end).Offset])

	flags := StructFlags{
		ProcessStruct: false,
		PtrReceiver:   false,
		Visibility:    ExportedVisibility,
	}

	if ConstructorPackageRegexp.MatchString(result) {
		flags.ProcessStruct = true
		flags.Visibility = PackageLevelVisibility
	} else if ConstructorExportedRegexp.MatchString(result) {
		flags.ProcessStruct = true
		flags.Visibility = ExportedVisibility
	} else if ConstructorNoRegexp.MatchString(result) {
		flags.ProcessStruct = true
		flags.Visibility = NoVisibility
	}

	return flags
}

// constructorFlagsFromField parses constructor flags from field comments for inner structs
func (sp *StructParser) constructorFlagsFromField(field *ast.Field) StructFlags {
	flags := StructFlags{
		ProcessStruct: false,
		PtrReceiver:   false,
		Visibility:    ExportedVisibility,
	}

	if field == nil {
		return flags
	}

	// Check both field.Comment and field.Doc for comments
	var commentText string
	if field.Comment != nil {
		commentText += field.Comment.Text()
	}
	if field.Doc != nil {
		commentText += field.Doc.Text()
	}

	// Always check the line where the field is defined for inline comments
	// Get the entire line content to check for inline comments
	begin := field.Pos()
	line := sp.fileSet.Position(begin).Line
	lineStart := sp.fileSet.File(begin).LineStart(line)

	var lineEnd token.Pos
	if line < sp.fileSet.File(begin).LineCount() {
		lineEnd = sp.fileSet.File(begin).LineStart(line+1) - 1
	} else {
		lineEnd = token.Pos(len(sp.fileContent))
	}

	startOffset := sp.fileSet.Position(lineStart).Offset
	endOffset := sp.fileSet.Position(lineEnd).Offset

	if startOffset < len(sp.fileContent) && endOffset <= len(sp.fileContent) {
		lineContent := string(sp.fileContent[startOffset:endOffset])
		// Look for comments on this line
		if idx := strings.Index(lineContent, "//"); idx != -1 {
			inlineComment := lineContent[idx:]
			commentText += inlineComment
		}
	}

	if ConstructorPackageRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = PackageLevelVisibility
	} else if ConstructorExportedRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = ExportedVisibility
	} else if ConstructorNoRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = NoVisibility
	}

	return flags
}

// getInnerStructFieldType extracts the type for inner struct fields
func (sp *StructParser) getInnerStructFieldType(field *ast.Field, parentStructName string) string {
	// Handle both direct struct types and pointer to struct types
	switch t := field.Type.(type) {
	case *ast.StructType:
		// Direct struct type: struct { ... }
		return sp.buildStructTypeString(t)
	case *ast.StarExpr:
		// Pointer to struct type: *struct { ... }
		if structType, ok := t.X.(*ast.StructType); ok {
			return "*" + sp.buildStructTypeString(structType)
		}
	}

	return "struct{}" // Fallback
}

// getInnerStructFieldTypeWithAlias gets the field type for inner structs, using type alias if available
func (sp *StructParser) getInnerStructFieldTypeWithAlias(field *ast.Field, parentStructName string, allStructs []*StructInfo) string {
	// Check if we have a generated type alias for this inner struct
	for _, fieldName := range field.Names {
		expectedTypeName := parentStructName + fieldName.Name

		// Look for this type in the allStructs list
		for _, structInfo := range allStructs {
			if structInfo.Name == expectedTypeName && structInfo.TypeSpec == nil {
				// This is an inner struct - check if it has constructor annotation
				if structInfo.Field != nil {
					flags := sp.constructorFlagsFromField(structInfo.Field)
					if flags.ProcessStruct {
						// We have a type alias for this inner struct
						switch field.Type.(type) {
						case *ast.StructType:
							return expectedTypeName
						case *ast.StarExpr:
							return "*" + expectedTypeName
						}
					}
				}
			}
		}
	}

	// No type alias available, fall back to inline struct type
	return sp.getInnerStructFieldType(field, parentStructName)
}

// buildStructTypeString builds a struct type string from AST
func (sp *StructParser) buildStructTypeString(st *ast.StructType) string {
	var fieldParts []string

	for _, field := range st.Fields.List {
		fieldType := sp.getFieldTypeFromAST(field.Type)

		// Extract struct tag if present
		var tag string
		if field.Tag != nil {
			tag = " " + field.Tag.Value // field.Tag.Value includes the backticks
		}

		for _, name := range field.Names {
			// Use the original field name (don't capitalize) to match the struct definition
			fieldParts = append(fieldParts, fmt.Sprintf("%s %s%s", name.Name, fieldType, tag))
		}
	}

	// Join fields with semicolons and wrap in struct { }
	return fmt.Sprintf("struct { %s }", strings.Join(fieldParts, "; "))
}

// getFieldTypeFromAST extracts field type from AST node
func (sp *StructParser) getFieldTypeFromAST(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + sp.getFieldTypeFromAST(t.X)
	case *ast.ArrayType:
		return "[]" + sp.getFieldTypeFromAST(t.Elt)
	case *ast.MapType:
		keyType := sp.getFieldTypeFromAST(t.Key)
		valueType := sp.getFieldTypeFromAST(t.Value)
		return fmt.Sprintf("map[%s]%s", keyType, valueType)
	case *ast.SelectorExpr:
		pkg := sp.getFieldTypeFromAST(t.X)
		return fmt.Sprintf("%s.%s", pkg, t.Sel.Name)
	case *ast.InterfaceType:
		if len(t.Methods.List) == 0 {
			return "interface{}"
		}
		return "interface{}" // Simplified
	case *ast.StructType:
		// Nested struct - recursively build it
		return sp.buildStructTypeString(t)
	default:
		return "interface{}" // Fallback
	}
}
