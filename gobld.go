package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"regexp"
	"strings"
	"unicode"
)

type Visibility int

const (
	ExportedVisibility Visibility = iota
	PackageLevelVisibility
	NoVisibility
)

type StructParser struct {
	fileSet                   *token.FileSet
	fileContent               []byte
	whitespaceRegexp          *regexp.Regexp
	constructorExportedRegexp *regexp.Regexp
	constructorPackageRegexp  *regexp.Regexp
	constructorNoRegexp       *regexp.Regexp
	flagReceiverPtrRegexp     *regexp.Regexp
	flagOptionalRegexp        *regexp.Regexp
	flagGetterRegexp          *regexp.Regexp
	flagAcronymRegex          *regexp.Regexp
}

type GobBuilder struct {
	common               strings.Builder
	constructorValueDef  strings.Builder
	constructorValueBody strings.Builder
	constructorPtrDef    strings.Builder
	constructorPtrBody   strings.Builder
	getters              strings.Builder
	astFile              *ast.File
}

type StructFlags struct {
	ProcessStruct bool
	PtrReceiver   bool
	Visibility    Visibility
}

func (bld *GobBuilder) appendPackage() {
	bld.common.WriteString("// Code generated by gobetter; DO NOT EDIT.\n\n")
	bld.common.WriteString(fmt.Sprintf("package %s\n\n", bld.astFile.Name.Name))
}

func (bld *GobBuilder) appendImports() {
	bld.common.WriteString("import (\n")
	for _, i := range bld.astFile.Imports {
		bld.common.WriteString(fmt.Sprintf("\t%s\n", i.Path.Value))
	}
	bld.common.WriteString(")\n\n")
}

func (bld *GobBuilder) appendArgStruct(
	structName string, fieldName string, fieldType string, structFlags StructFlags, acronym bool,
) (structArgName string) {
	var visibleFieldName string
	if acronym {
		visibleFieldName = strings.ToUpper(fieldName)
	} else {
		visibleFieldName = strings.Title(fieldName)
	}
	visibleStructName := convertStructNameAccordingToVisibility(structName, structFlags.Visibility)
	structArgName = newStructArgName(structName, fieldName, structFlags.Visibility, acronym)
	bld.common.WriteString(fmt.Sprintf("// %s represents field %s of struct %s\n", structArgName, fieldName, structName))
	bld.common.WriteString(fmt.Sprintf("type %s struct {\n", structArgName))
	bld.common.WriteString(fmt.Sprintf("\tArg %s\n}\n", fieldType))
	bld.common.WriteString(fmt.Sprintf("// %s%s creates argument for field %s\n", visibleStructName, strings.Title(fieldName), fieldName))
	bld.common.WriteString(fmt.Sprintf("func %s_%s(arg %s) %s {\n",
		visibleStructName,
		visibleFieldName,
		fieldType, structArgName))
	bld.common.WriteString(fmt.Sprintf("\treturn %s{Arg: arg}\n}\n\n", structArgName))
	return
}

func (bld *GobBuilder) appendArgStructConstructor(
	structName string, fieldName string, fieldType string, visibility Visibility, acronym bool,
) (structArgName string) {
	structArgName = newStructArgName(structName, fieldName, visibility, acronym)
	bld.common.WriteString(fmt.Sprintf("func %s%s(arg %s) %s {\n", structName, fieldName,
		fieldType, structArgName))
	bld.common.WriteString(fmt.Sprintf("\treturn %s{Arg: arg}\n}\n\n", structArgName))
	return
}

func newStructArgName(structName string, fieldName string, visibility Visibility, acronym bool) string {
	var title string
	if acronym {
		title = strings.ToUpper(fieldName)
	} else {
		title = strings.Title(fieldName)
	}
	return convertStructNameAccordingToVisibility(structName, visibility) + "_" + title + "_ArgWrapper"
}

func convertStructNameAccordingToVisibility(structName string, visibility Visibility) string {
	if visibility == PackageLevelVisibility {
		return untitle(structName)
	}
	return structName
}

func untitle(value string) string {
	return string(unicode.ToLower(rune(value[0]))) + value[1:]
}

func (bld *GobBuilder) appendBeginConstructorDef(structName string, structFlags StructFlags) {
	var funcName string
	firstChar := rune(structName[0])
	if unicode.IsLower(firstChar) || structFlags.Visibility == PackageLevelVisibility {
		funcName = "new" + strings.Title(structName)
	} else {
		funcName = "New" + strings.Title(structName)
	}
	bld.constructorValueDef.WriteString(fmt.Sprintf("// %s creates new instance of %s struct\n", funcName, structName))
	bld.constructorValueDef.WriteString(fmt.Sprintf("func %s(\n", funcName))
	bld.constructorPtrDef.WriteString(fmt.Sprintf("// %s_Ptr returns pointer to new instance of %s struct\n", funcName, structName))
	bld.constructorPtrDef.WriteString(fmt.Sprintf("func %s_Ptr(\n", funcName))
}

func (bld *GobBuilder) appendBeginConstructorBody(structName string) {
	bld.constructorValueBody.WriteString(fmt.Sprintf("\treturn %s{\n", structName))
	bld.constructorPtrBody.WriteString(fmt.Sprintf("\treturn &%s{\n", structName))
}

func (bld *GobBuilder) appendConstructorArg(fieldName string, structArgName string, acronym bool) {
	var visibleFieldName string
	if acronym {
		visibleFieldName = strings.ToUpper(fieldName)
	} else {
		visibleFieldName = strings.Title(fieldName)
	}
	argName := "arg" + visibleFieldName
	def := fmt.Sprintf("\t%s %s,\n", argName, structArgName)
	value := fmt.Sprintf("\t\t%s: %s.Arg,\n", fieldName, argName)
	bld.constructorValueDef.WriteString(def)
	bld.constructorValueBody.WriteString(value)
	bld.constructorPtrDef.WriteString(def)
	bld.constructorPtrBody.WriteString(value)
}

func (bld *GobBuilder) appendGetter(
	structName string, fieldName string, fieldType string, flags StructFlags, acronym bool,
) {
	ptr := ""
	if flags.PtrReceiver {
		ptr = "*"
	}
	var addedFieldName string
	if acronym {
		addedFieldName = strings.ToUpper(fieldName)
	} else {
		addedFieldName = strings.Title(fieldName)
	}
	bld.common.WriteString(fmt.Sprintf("func (v %s%s) %s() %s {\n", ptr, structName, addedFieldName, fieldType))
	bld.common.WriteString(fmt.Sprintf("\treturn v.%s\n", fieldName))
	bld.common.WriteString("}\n\n")
}

func (bld *GobBuilder) Build() string {
	return bld.common.String()
}

func (bld *GobBuilder) AcceptStruct(structName string) {
	if bld.getters.Len() > 0 {
		bld.common.WriteString(bld.getters.String())
		bld.common.WriteString("}\n")
	}
	if bld.constructorValueDef.Len() > 0 {
		bld.common.WriteString(bld.constructorValueDef.String())
		bld.common.WriteString(fmt.Sprintf(") %s {\n", structName))
		bld.common.WriteString(bld.constructorValueBody.String())
		bld.common.WriteString("\t}\n")
		bld.common.WriteString("}\n")
	}
	if bld.constructorPtrDef.Len() > 0 {
		bld.common.WriteString(bld.constructorPtrDef.String())
		bld.common.WriteString(fmt.Sprintf(") *%s {\n", structName))
		bld.common.WriteString(bld.constructorPtrBody.String())
		bld.common.WriteString("\t}\n")
		bld.common.WriteString("}\n")
	}
	bld.constructorValueDef.Reset()
	bld.constructorValueBody.Reset()
	bld.constructorPtrDef.Reset()
	bld.constructorPtrBody.Reset()
	bld.getters.Reset()
}

func NewStructParser(fileSet *token.FileSet, fileContent []byte) StructParser {
	return StructParser{
		fileSet:                   fileSet,
		fileContent:               fileContent,
		whitespaceRegexp:          regexp.MustCompile(`\s+`),
		constructorExportedRegexp: regexp.MustCompile(`\b+gob:Constructor\b`),
		constructorPackageRegexp:  regexp.MustCompile(`\b+gob:constructor\b`),
		constructorNoRegexp:       regexp.MustCompile(`\b+gob:_\b`),
		flagReceiverPtrRegexp:     regexp.MustCompile(`\b+gob:ptr\b`),
		flagOptionalRegexp:        regexp.MustCompile(`\b+gob:_\b`),
		flagGetterRegexp:          regexp.MustCompile(`\b+gob:getter\b`),
		flagAcronymRegex:          regexp.MustCompile(`\b+gob:acronym\b`),
	}
}

func (sp *StructParser) fieldTypeText(field *ast.Field) string {
	begin := sp.fileSet.Position(field.Type.Pos()).Offset
	end := sp.fileSet.Position(field.Type.End()).Offset
	return sp.whitespaceRegexp.ReplaceAllString(string(sp.fileContent[begin:end]), " ")
}

func (sp *StructParser) fieldOptional(field *ast.Field) bool {
	return sp.flagOptionalRegexp.MatchString(field.Comment.Text())
}

func (sp *StructParser) fieldGetter(field *ast.Field) bool {
	return sp.flagGetterRegexp.MatchString(field.Comment.Text())
}

func (sp *StructParser) fieldAcronym(field *ast.Field) bool {
	return sp.flagAcronymRegex.MatchString(field.Comment.Text())
}

func (sp *StructParser) constructorFlags(st *ast.StructType) StructFlags {
	begin := st.Struct
	endLine := sp.fileSet.File(begin).Line(begin) + 1
	end := sp.fileSet.File(begin).LineStart(endLine)
	result := string(sp.fileContent[sp.fileSet.Position(begin).Offset:sp.fileSet.Position(end).Offset])
	flags := StructFlags{
		ProcessStruct: false,
		PtrReceiver:   false,
		Visibility:    ExportedVisibility,
	}
	if sp.constructorPackageRegexp.MatchString(result) {
		flags.ProcessStruct = true
		flags.Visibility = PackageLevelVisibility
	} else if sp.constructorExportedRegexp.MatchString(result) {
		flags.ProcessStruct = true
		flags.Visibility = ExportedVisibility
	} else if sp.constructorNoRegexp.MatchString(result) {
		flags.ProcessStruct = true
		flags.Visibility = NoVisibility
	}

	if sp.flagReceiverPtrRegexp.MatchString(result) {
		flags.ProcessStruct = true
		flags.PtrReceiver = true
	}

	return flags
}
