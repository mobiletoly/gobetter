package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"regexp"
	"strings"
	"unicode"
)

type Visibility int

const (
	ExportedVisibility Visibility = iota
	PackageLevelVisibility
	NoVisibility
)

type StructParser struct {
	fileSet                   *token.FileSet
	fileContent               []byte
	whitespaceRegexp          *regexp.Regexp
	constructorExportedRegexp *regexp.Regexp
	constructorPackageRegexp  *regexp.Regexp
	constructorNoRegexp       *regexp.Regexp
	flagOptionalRegexp        *regexp.Regexp
	flagGetterRegexp          *regexp.Regexp
	flagAcronymRegex          *regexp.Regexp
}

type StructField struct {
	StructFlags   *StructFlags
	StructName    string
	FieldName     string
	FieldTypeText string
	Acronym       bool
}

type StructFlags struct {
	ProcessStruct bool
	PtrReceiver   bool
	Visibility    Visibility
}

func GeneratePackage(astFile *ast.File) string {
	bld := &strings.Builder{}
	bld.WriteString("// Code generated by gobetter; DO NOT EDIT.\n\n")
	bld.WriteString(fmt.Sprintf("package %s\n\n", astFile.Name.Name))
	return bld.String()
}

func GenerateImports(astFile *ast.File) string {
	bld := &strings.Builder{}
	bld.WriteString("import (\n")
	for _, i := range astFile.Imports {
		bld.WriteString(fmt.Sprintf("\t%s\n", i.Path.Value))
	}
	bld.WriteString(")\n\n")
	return bld.String()
}

func (sf *StructField) GenerateGetter() string {
	var addedFieldName string
	if sf.Acronym {
		addedFieldName = strings.ToUpper(sf.FieldName)
	} else {
		addedFieldName = strings.Title(sf.FieldName)
	}
	return fmt.Sprintf(`
func (v *%s) %s() %s {
	return v.%s
}

`, sf.StructName, addedFieldName, sf.FieldTypeText,
		sf.FieldName)
}

func (sf *StructField) GenerateSourceCodeForStructField(prev *StructField, last bool) string {
	bld := &strings.Builder{}
	if prev == nil {
		sf.generateConstructor(bld)
	}
	sf.generateBuilderStruct(bld)
	if prev != nil {
		sf.generateBuilderSetter(bld, prev)
		if last {
			sf.generateBuildFunction(bld)
		}
	}
	return bld.String()
}

func (sf *StructField) generateBuildFunction(bld *strings.Builder) {
	builderStructName := sf.builderFieldStructName()
	bld.WriteString(fmt.Sprintf(`
func (b %s) Build() *%s {
    return b.root
}

`, builderStructName, sf.StructName,
	))
}

func (sf *StructField) generateBuilderStruct(bld *strings.Builder) {
	builderStructName := sf.builderFieldStructName()
	bld.WriteString(fmt.Sprintf(`
type %s struct {
    root *%s
}

`, builderStructName, sf.StructName))
}

func (sf *StructField) generateBuilderSetter(bld *strings.Builder, prev *StructField) {
	var setterName string
	if prev.Acronym {
		setterName = strings.ToUpper(prev.FieldName)
	} else {
		setterName = strings.Title(prev.FieldName)
	}

	prevBuilderStructName := prev.builderFieldStructName()
	builderStructName := sf.builderFieldStructName()
	bld.WriteString(fmt.Sprintf(`
func (b %s) %s(arg %s) %s {
    b.root.%s = arg
    return %s{root: b.root}
}

`, prevBuilderStructName, setterName, prev.FieldTypeText, builderStructName,
		prev.FieldName,
		builderStructName,
	))
}

func (sf *StructField) generateConstructor(bld *strings.Builder) {
	builderStructName := sf.builderFieldStructName()
	var funcName string
	firstChar := rune(sf.StructName[0])
	if unicode.IsLower(firstChar) || sf.StructFlags.Visibility == PackageLevelVisibility {
		funcName = "new" + strings.Title(sf.StructName)
	} else {
		funcName = "New" + strings.Title(sf.StructName)
	}
	bld.WriteString(fmt.Sprintf(`
func %sBuilder() %s {
	return %s{root: &%s{}}
}

`,
		funcName, builderStructName,
		builderStructName, sf.StructName,
	))
}

func (sf *StructField) builderFieldStructName() string {
	var title string
	if sf.Acronym {
		title = strings.ToUpper(sf.FieldName)
	} else {
		title = strings.Title(sf.FieldName)
	}
	return sf.StructName + "_Builder_" + title
}

func NewStructParser(fileSet *token.FileSet, fileContent []byte) StructParser {
	return StructParser{
		fileSet:                   fileSet,
		fileContent:               fileContent,
		whitespaceRegexp:          regexp.MustCompile(`\s+`),
		constructorExportedRegexp: regexp.MustCompile(`\b+gob:Constructor\b`),
		constructorPackageRegexp:  regexp.MustCompile(`\b+gob:constructor\b`),
		constructorNoRegexp:       regexp.MustCompile(`\b+gob:_\b`),
		flagOptionalRegexp:        regexp.MustCompile(`\b+gob:_\b`),
		flagGetterRegexp:          regexp.MustCompile(`\b+gob:getter\b`),
		flagAcronymRegex:          regexp.MustCompile(`\b+gob:acronym\b`),
	}
}

func (sp *StructParser) fieldTypeText(field *ast.Field) string {
	begin := sp.fileSet.Position(field.Type.Pos()).Offset
	end := sp.fileSet.Position(field.Type.End()).Offset
	return sp.whitespaceRegexp.ReplaceAllString(string(sp.fileContent[begin:end]), " ")
}

func (sp *StructParser) fieldOptional(field *ast.Field) bool {
	return sp.flagOptionalRegexp.MatchString(field.Comment.Text())
}

func (sp *StructParser) fieldGetter(field *ast.Field) bool {
	return sp.flagGetterRegexp.MatchString(field.Comment.Text())
}

func (sp *StructParser) fieldAcronym(field *ast.Field) bool {
	return sp.flagAcronymRegex.MatchString(field.Comment.Text())
}

func (sp *StructParser) constructorFlags(st *ast.StructType) StructFlags {
	begin := st.Struct
	endLine := sp.fileSet.File(begin).Line(begin) + 1
	end := sp.fileSet.File(begin).LineStart(endLine)
	result := string(sp.fileContent[sp.fileSet.Position(begin).Offset:sp.fileSet.Position(end).Offset])
	flags := StructFlags{
		ProcessStruct: false,
		PtrReceiver:   false,
		Visibility:    ExportedVisibility,
	}
	if sp.constructorPackageRegexp.MatchString(result) {
		flags.ProcessStruct = true
		flags.Visibility = PackageLevelVisibility
	} else if sp.constructorExportedRegexp.MatchString(result) {
		flags.ProcessStruct = true
		flags.Visibility = ExportedVisibility
	} else if sp.constructorNoRegexp.MatchString(result) {
		flags.ProcessStruct = true
		flags.Visibility = NoVisibility
	}

	return flags
}
