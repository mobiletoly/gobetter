package main

import (
	"fmt"
	"go/ast"
	"go/token"
	"strings"
	"unicode"
	"unicode/utf8"
)

type Visibility int

const (
	ExportedVisibility Visibility = iota
	PackageLevelVisibility
	NoVisibility
)

// StructParser handles parsing of Go struct definitions and their annotations
type StructParser struct {
	fileSet     *token.FileSet
	fileContent []byte
	aliasMap    map[*ast.StructType]*StructInfo
}

// StructField represents a field in a struct that needs builder generation
type StructField struct {
	StructFlags   *StructFlags
	StructName    string
	FieldName     string
	FieldTypeText string
	Acronym       bool
	TypeParamDecl string
	TypeParamUse  string
}

func (sf *StructField) structTypeUsage() string {
	if sf.TypeParamUse != "" {
		return sf.StructName + sf.TypeParamUse
	}
	return sf.StructName
}

func (sf *StructField) builderStructDecl() string {
	name := sf.builderFieldStructName()
	if sf.TypeParamDecl != "" {
		return name + sf.TypeParamDecl
	}
	return name
}

func (sf *StructField) builderStructUsage() string {
	name := sf.builderFieldStructName()
	if sf.TypeParamUse != "" {
		return name + sf.TypeParamUse
	}
	return name
}

// StructFlags contains configuration flags for struct processing
type StructFlags struct {
	ProcessStruct bool
	Visibility    Visibility
}

// GeneratePackage generates the package declaration for the output file
func GeneratePackage(astFile *ast.File, signature string) string {
	var bld strings.Builder
	bld.WriteString("// Code generated by gobetter; DO NOT EDIT.\n")
	if signature != "" {
		bld.WriteString("// gobetter:signature=")
		bld.WriteString(signature)
		bld.WriteString("\n")
	}
	bld.WriteString("\n")
	bld.WriteString(fmt.Sprintf("package %s\n\n", astFile.Name.Name))
	return bld.String()
}

// GenerateGetter generates a getter method for a struct field
func (sf *StructField) GenerateGetter() string {
	methodName := exportName(sf.FieldName, sf.Acronym)

	// Default to pointer receiver for backward compatibility unless explicitly set to value.
	receiverType := "*" + sf.structTypeUsage()
	return fmt.Sprintf(`
func (v %s) %s() %s {
	return v.%s
}

`, receiverType, methodName, sf.FieldTypeText, sf.FieldName)
}

// GenerateSourceCodeForStructField generates the builder code for a struct field
func (sf *StructField) GenerateSourceCodeForStructField(prev *StructField, last bool) string {
	var bld strings.Builder

	if prev == nil {
		sf.generateConstructor(&bld)
	}
	sf.generateBuilderStruct(&bld)
	if prev != nil {
		sf.generateBuilderSetter(&bld, prev)
	}
	if last {
		finalSf := StructField{
			StructFlags:   sf.StructFlags,
			StructName:    sf.StructName,
			FieldName:     GobFinalizerName,
			FieldTypeText: "PLACEHOLDER", // This value is not used in the final output
			Acronym:       false,
			TypeParamDecl: sf.TypeParamDecl,
			TypeParamUse:  sf.TypeParamUse,
		}
		finalSf.generateBuilderStruct(&bld)
		finalSf.generateBuilderSetter(&bld, sf)
		finalSf.generateBuildFunction(&bld)
	}
	return bld.String()
}

// generateBuildFunction generates the final Build() method
func (sf *StructField) generateBuildFunction(bld *strings.Builder) {
	builderUsage := sf.builderStructUsage()
	structUsage := sf.structTypeUsage()
	bld.WriteString(fmt.Sprintf(`
func (b %s) %s() *%s {
	return b.root
}

`, builderUsage, BuildMethodName, structUsage))
}

// generateBuilderStruct generates a builder struct type
func (sf *StructField) generateBuilderStruct(bld *strings.Builder) {
	builderDecl := sf.builderStructDecl()
	structUsage := sf.structTypeUsage()
	bld.WriteString(fmt.Sprintf(`
type %s struct {
	root *%s
}

`, builderDecl, structUsage))
}

// generateBuilderSetter generates a setter method for the builder
func (sf *StructField) generateBuilderSetter(bld *strings.Builder, prev *StructField) {
	setterName := exportName(prev.FieldName, prev.Acronym)
	prevBuilderUsage := prev.builderStructUsage()
	builderUsage := sf.builderStructUsage()
	bld.WriteString(fmt.Sprintf(`
func (b %s) %s(arg %s) %s {
	b.root.%s = arg
	return %s{root: b.root}
}

`, prevBuilderUsage, setterName, prev.FieldTypeText, builderUsage,
		prev.FieldName, builderUsage))
}

// generateConstructor generates the constructor function for the builder
func (sf *StructField) generateConstructor(bld *strings.Builder) {
	builderUsage := sf.builderStructUsage()
	structUsage := sf.structTypeUsage()

	var funcName string
	firstChar := rune(sf.StructName[0])
	if unicode.IsLower(firstChar) || sf.StructFlags.Visibility == PackageLevelVisibility {
		funcName = LowerNewPrefix + upperFirstASCIIOrUnicode(sf.StructName)
	} else {
		funcName = NewPrefix + upperFirstASCIIOrUnicode(sf.StructName)
	}

	bld.WriteString(fmt.Sprintf(`
func %s%s%s() %s {
	return %s{root: &%s{}}
}

`, funcName, BuilderSuffix, sf.TypeParamDecl, builderUsage, builderUsage, structUsage))
}

// builderFieldStructName generates the name for a builder struct
func (sf *StructField) builderFieldStructName() string {
	return sf.StructName + BuilderPrefix + exportName(sf.FieldName, sf.Acronym)
}

// NewStructParser creates a new StructParser instance
func NewStructParser(fileSet *token.FileSet, fileContent []byte) StructParser {
	return StructParser{
		fileSet:     fileSet,
		fileContent: fileContent,
	}
}

// SetAliasMap configures known struct aliases for the parser.
func (sp *StructParser) SetAliasMap(aliasMap map[*ast.StructType]*StructInfo) {
	sp.aliasMap = aliasMap
}

func (sp *StructParser) formatter(exclude *ast.StructType) *TypeFormatter {
	tf := newDefaultTypeFormatter()
	if sp.aliasMap != nil {
		tf.AliasResolver = func(st *ast.StructType) (string, bool) {
			if st == exclude {
				return "", false
			}
			if info, ok := sp.aliasMap[st]; ok && info != nil {
				return info.Name + info.TypeParamUse, true
			}
			return "", false
		}
	}
	return tf
}

// fieldTypeText extracts the type text for a field using the AST pretty-printer,
// ensuring valid Go syntax (e.g., semicolons between interface methods).
func (sp *StructParser) fieldTypeText(field *ast.Field) string {
	if field == nil || field.Type == nil {
		return ""
	}
	return sp.formatter(nil).Format(field.Type)
}

// fieldCommentText returns all comments relevant to a field:
// - trailing line comment (inline, same line as the field)
// - field.Comment (trailing comment group)
// - field.Doc (leading doc comment group)
func (sp *StructParser) fieldCommentText(field *ast.Field) string {
	if field == nil {
		return ""
	}

	var b strings.Builder
	if field.Comment != nil {
		b.WriteString(field.Comment.Text())
	}
	if field.Doc != nil {
		b.WriteString(field.Doc.Text())
	}

	// Add inline comment on the same line as the field declaration, if present.
	begin := field.Pos()
	file := sp.fileSet.File(begin)
	if file == nil {
		return b.String()
	}
	line := sp.fileSet.Position(begin).Line
	lineStart := file.LineStart(line)

	var lineEnd token.Pos
	if line < file.LineCount() {
		lineEnd = file.LineStart(line+1) - 1
	} else {
		lineEnd = token.Pos(len(sp.fileContent))
	}

	startOffset := sp.fileSet.Position(lineStart).Offset
	endOffset := sp.fileSet.Position(lineEnd).Offset

	if startOffset >= 0 && endOffset >= 0 && startOffset < endOffset && endOffset <= len(sp.fileContent) {
		lineContent := string(sp.fileContent[startOffset:endOffset])
		if idx := strings.Index(lineContent, "//"); idx != -1 {
			b.WriteString(lineContent[idx:])
		}
	}

	return b.String()
}

// fieldOptional checks if a field is marked as optional
func (sp *StructParser) fieldOptional(field *ast.Field) bool {
	return FlagOptionalRegexp.MatchString(sp.fieldCommentText(field))
}

// fieldGetter checks if a field should have a getter generated
func (sp *StructParser) fieldGetter(field *ast.Field) bool {
	return FlagGetterRegexp.MatchString(sp.fieldCommentText(field))
}

// fieldAcronym checks if a field is marked as an acronym
func (sp *StructParser) fieldAcronym(field *ast.Field) bool {
	return FlagAcronymRegexp.MatchString(sp.fieldCommentText(field))
}

// constructorFlags parses constructor flags from the type line and any contiguous
// doc comments immediately above it. We intentionally work from the StructType's
// `struct` token position and walk the file lines using fileSet, so we don't
// require the caller to pass *ast.TypeSpec or *ast.GenDecl.
func (sp *StructParser) constructorFlags(st *ast.StructType) StructFlags {
	flags := StructFlags{
		ProcessStruct: false,
		Visibility:    ExportedVisibility,
	}

	begin := st.Struct
	file := sp.fileSet.File(begin)
	if file == nil {
		return flags
	}

	// Line containing the `struct` keyword (usually the `type ... struct {` line)
	line := file.Line(begin)

	// Helper to fetch raw bytes for a given 1-based line number.
	getLine := func(ln int) string {
		if ln < 1 || ln > file.LineCount() {
			return ""
		}
		start := file.LineStart(ln)
		var end token.Pos
		if ln < file.LineCount() {
			end = file.LineStart(ln+1) - 1
		} else {
			end = token.Pos(len(sp.fileContent))
		}
		startOffset := sp.fileSet.Position(start).Offset
		endOffset := sp.fileSet.Position(end).Offset
		if startOffset < 0 || endOffset < 0 || startOffset > len(sp.fileContent) || endOffset > len(sp.fileContent) || startOffset >= endOffset {
			return ""
		}
		return string(sp.fileContent[startOffset:endOffset])
	}

	var builder strings.Builder

	// 1) Inline comment on the type line (same line as `struct`).
	typeLine := getLine(line)
	if idx := strings.Index(typeLine, "//"); idx != -1 {
		builder.WriteString(typeLine[idx:])
		builder.WriteString("\n")
	}

	// 2) Contiguous doc comment block immediately above (lines starting with //).
	for ln := line - 1; ln >= 1; ln-- {
		txt := strings.TrimSpace(getLine(ln))
		if txt == "" {
			// Blank lines break a Go doc comment group; stop collecting.
			break
		}
		if strings.HasPrefix(txt, "//") {
			// Prepend to preserve natural order.
			builder.WriteString(txt)
			builder.WriteString("\n")
			continue
		}
		// Non-comment code or other text stops the doc comment block.
		break
	}

	commentText := builder.String()

	if ConstructorPackageRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = PackageLevelVisibility
	} else if ConstructorExportedRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = ExportedVisibility
	} else if ConstructorNoRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = NoVisibility
	}

	return flags
}

// constructorFlagsFromField parses constructor flags from field comments for inner structs
func (sp *StructParser) constructorFlagsFromField(field *ast.Field) StructFlags {
	flags := StructFlags{
		ProcessStruct: false,
		Visibility:    ExportedVisibility,
	}
	if field == nil {
		return flags
	}
	commentText := sp.fieldCommentText(field)

	if ConstructorPackageRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = PackageLevelVisibility
	} else if ConstructorExportedRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = ExportedVisibility
	} else if ConstructorNoRegexp.MatchString(commentText) {
		flags.ProcessStruct = true
		flags.Visibility = NoVisibility
	}
	return flags
}

// getInnerStructFieldType extracts the type for inner struct fields
func (sp *StructParser) getInnerStructFieldType(field *ast.Field, parentStructName string) string {
	// Handle both direct struct types and pointer to struct types
	switch t := field.Type.(type) {
	case *ast.StructType:
		f := sp.formatter(t)
		return f.StructHandler(f, t)
	case *ast.StarExpr:
		// Pointer to struct type: *struct { ... }
		if structType, ok := t.X.(*ast.StructType); ok {
			formatter := sp.formatter(structType)
			return "*" + formatter.StructHandler(formatter, structType)
		}
	}

	return "struct{}" // Fallback
}

// getInnerStructFieldTypeWithAlias gets the field type for inner structs, using type alias if available
func (sp *StructParser) getInnerStructFieldTypeWithAlias(field *ast.Field, parentStructName string) string {
	if sp.aliasMap != nil {
		switch t := field.Type.(type) {
		case *ast.StructType:
			if info, ok := sp.aliasMap[t]; ok && info != nil {
				return info.Name + info.TypeParamUse
			}
		case *ast.StarExpr:
			if structType, ok := t.X.(*ast.StructType); ok {
				if info, ok := sp.aliasMap[structType]; ok && info != nil {
					return "*" + info.Name + info.TypeParamUse
				}
			}
		}
	}

	// No type alias available, fall back to inline struct type
	return sp.getInnerStructFieldType(field, parentStructName)
}

// upperFirstASCIIOrUnicode upper-cases the first character in a string.
func upperFirstASCIIOrUnicode(s string) string {
	if s == "" {
		return s
	}
	r, sz := utf8.DecodeRuneInString(s)
	return strings.ToUpper(string(r)) + s[sz:]
}

// exportName centralizes the decision of how to render a field/method name with acronym flag support.
func exportName(s string, acronym bool) string {
	if acronym {
		return strings.ToUpper(s)
	}
	return upperFirstASCIIOrUnicode(s)
}
